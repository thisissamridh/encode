"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCircuitSize = exports.StandardExampleProver = void 0;
const wasm_1 = require("../../wasm");
class StandardExampleProver {
    constructor(prover) {
        this.prover = prover;
    }
    // We do not pass in a constraint_system to this method
    // so that users cannot call it twice and possibly be
    // in a state where they have a different circuit definition to
    // the proving key
    //
    //Ideally, we want this to be called in the constructor and not be manually called by users. Possibly create a .new method
    async initCircuitDefinition(constraint_system) {
        let worker = this.prover.getWorker();
        const constraint_system_ptr = await worker.call('bbmalloc', constraint_system.length);
        await worker.transferToHeap(constraint_system, constraint_system_ptr);
        await worker.call('standard_example__init_circuit_def', constraint_system_ptr);
    }
    async computeKey() {
        const worker = this.prover.getWorker();
        await worker.call('standard_example__init_proving_key');
    }
    async createProof(witness_arr) {
        const worker = this.prover.getWorker();
        const witness_ptr = await worker.call('bbmalloc', witness_arr.length);
        await worker.transferToHeap(witness_arr, witness_ptr);
        const proverPtr = await worker.call('standard_example__new_prover', witness_ptr);
        const proof = await this.prover.createProof(proverPtr);
        await worker.call('standard_example__delete_prover', proverPtr);
        return proof;
    }
    getProver() {
        return this.prover;
    }
}
exports.StandardExampleProver = StandardExampleProver;
async function getCircuitSize(wasm, constraint_system) {
    let pool = new wasm_1.WorkerPool();
    await pool.init(wasm.module, 8);
    let worker = pool.workers[0];
    const buf = Buffer.from(constraint_system);
    const mem = await worker.call('bbmalloc', buf.length);
    await worker.transferToHeap(buf, mem);
    const circSize = await worker.call('standard_example__get_circuit_size', mem);
    // FFT requires the circuit size to be a power of two.
    // If it is not, then we round it up to the nearest power of two
    if (powerOf2(circSize)) {
        return circSize;
    }
    else {
        return pow2ceil(circSize);
    }
}
exports.getCircuitSize = getCircuitSize;
// Returns true, if `v` is a power of two
function powerOf2(v) {
    return v && !(v & (v - 1));
}
// Rounds `v` up to the next power of two.
// Note: If `v` is already a power of two, it will still round `v`
// to the next power of two
function pow2ceil(v) {
    var p = 2;
    while ((v >>= 1)) {
        p <<= 1;
    }
    return p;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhbmRhcmRfZXhhbXBsZV9wcm92ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY2xpZW50X3Byb29mcy9nZW5lcmljX3Byb29mL3N0YW5kYXJkX2V4YW1wbGVfcHJvdmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLHFDQUEwRDtBQUUxRCxNQUFhLHFCQUFxQjtJQUNoQyxZQUFvQixNQUFjO1FBQWQsV0FBTSxHQUFOLE1BQU0sQ0FBUTtJQUFHLENBQUM7SUFFdEMsdURBQXVEO0lBQ3ZELHFEQUFxRDtJQUNyRCwrREFBK0Q7SUFDL0Qsa0JBQWtCO0lBQ2xCLEVBQUU7SUFDRiwwSEFBMEg7SUFDbkgsS0FBSyxDQUFDLHFCQUFxQixDQUFDLGlCQUE2QjtRQUM5RCxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3JDLE1BQU0scUJBQXFCLEdBQUcsTUFBTSxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN0RixNQUFNLE1BQU0sQ0FBQyxjQUFjLENBQUMsaUJBQWlCLEVBQUUscUJBQXFCLENBQUMsQ0FBQztRQUV0RSxNQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUMsb0NBQW9DLEVBQUUscUJBQXFCLENBQUMsQ0FBQztJQUNqRixDQUFDO0lBRU0sS0FBSyxDQUFDLFVBQVU7UUFDckIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUN2QyxNQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUMsb0NBQW9DLENBQUMsQ0FBQztJQUMxRCxDQUFDO0lBRU0sS0FBSyxDQUFDLFdBQVcsQ0FBQyxXQUF1QjtRQUM5QyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBRXZDLE1BQU0sV0FBVyxHQUFHLE1BQU0sTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RFLE1BQU0sTUFBTSxDQUFDLGNBQWMsQ0FBQyxXQUFXLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFFdEQsTUFBTSxTQUFTLEdBQUcsTUFBTSxNQUFNLENBQUMsSUFBSSxDQUFDLDhCQUE4QixFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ2pGLE1BQU0sS0FBSyxHQUFHLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDdkQsTUFBTSxNQUFNLENBQUMsSUFBSSxDQUFDLGlDQUFpQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ2hFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVNLFNBQVM7UUFDZCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDckIsQ0FBQztDQUNGO0FBckNELHNEQXFDQztBQUVNLEtBQUssVUFBVSxjQUFjLENBQUMsSUFBc0IsRUFBRSxpQkFBNkI7SUFDeEYsSUFBSSxJQUFJLEdBQUcsSUFBSSxpQkFBVSxFQUFFLENBQUM7SUFDNUIsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDaEMsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUU3QixNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFDM0MsTUFBTSxHQUFHLEdBQUcsTUFBTSxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdEQsTUFBTSxNQUFNLENBQUMsY0FBYyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUV0QyxNQUFNLFFBQVEsR0FBRyxNQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUMsb0NBQW9DLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDOUUsc0RBQXNEO0lBQ3RELGdFQUFnRTtJQUNoRSxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRTtRQUN0QixPQUFPLFFBQVEsQ0FBQztLQUNqQjtTQUFNO1FBQ0wsT0FBTyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7S0FDM0I7QUFDSCxDQUFDO0FBakJELHdDQWlCQztBQUVELHlDQUF5QztBQUN6QyxTQUFTLFFBQVEsQ0FBQyxDQUFDO0lBQ2pCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM3QixDQUFDO0FBQ0QsMENBQTBDO0FBQzFDLGtFQUFrRTtBQUNsRSwyQkFBMkI7QUFDM0IsU0FBUyxRQUFRLENBQUMsQ0FBQztJQUNqQixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDVixPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO1FBQ2hCLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDVDtJQUNELE9BQU8sQ0FBQyxDQUFDO0FBQ1gsQ0FBQyJ9