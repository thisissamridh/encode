"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verify_proof = exports.create_proof_with_witness = exports.create_proof = exports.setup_generic_prover_and_verifier = void 0;
const tslib_1 = require("tslib");
// TODO: fix this typo of barretenberg spelling
const aztec_backend_1 = require("@noir-lang/aztec_backend");
const crs_1 = require("../../crs");
const fft_1 = require("../../fft");
const pippenger_1 = require("../../pippenger");
const wasm_1 = require("../../wasm");
const prover_1 = require("../prover");
const standard_example_prover_1 = require("./standard_example_prover");
const standard_example_verifier_1 = require("./standard_example_verifier");
(0, tslib_1.__exportStar)(require("./standard_example_prover"), exports);
(0, tslib_1.__exportStar)(require("./standard_example_verifier"), exports);
// Takes in a structure representing ACIR which we get from
// wasm version of the noir compiler
//
// We then serialise the ACIR into a byte array which represents
// what is known as standard_format in the C++ code.
//
// standard_format is capable of representing any statement.
//
// Note this byte array would be analogous to the `tx` structures
// in the other client proofs
async function setup_generic_prover_and_verifier(acir) {
    const serialised_circuit = (0, aztec_backend_1.serialise_acir_to_barrtenberg_circuit)(acir);
    const barretenberg = await wasm_1.BarretenbergWasm.new();
    const circSize = await (0, standard_example_prover_1.getCircuitSize)(barretenberg, serialised_circuit);
    const crs = await load_crs(circSize);
    const numWorkers = getNumCores();
    const wasm = await wasm_1.BarretenbergWasm.new();
    const workerPool = await wasm_1.WorkerPool.new(wasm, numWorkers);
    const pippenger = new pippenger_1.PooledPippenger(workerPool);
    const fft = new fft_1.PooledFft(workerPool);
    await fft.init(circSize);
    await pippenger.init(crs.getData());
    const prover = new prover_1.Prover(workerPool.workers[0], pippenger, fft);
    const standardExampleProver = new standard_example_prover_1.StandardExampleProver(prover);
    await standardExampleProver.initCircuitDefinition(serialised_circuit);
    const standardExampleVerifier = new standard_example_verifier_1.StandardExampleVerifier();
    // Create proving key with a dummy CRS
    await standardExampleProver.computeKey();
    // Create verifier key *and* patch proving key with the CRS
    await standardExampleVerifier.computeKey(pippenger.pool[0], crs.getG2Data());
    // Compute smart contract and cache it
    await standardExampleVerifier.computeSmartContract(pippenger.pool[0], crs.getG2Data(), serialised_circuit);
    return Promise.all([standardExampleProver, standardExampleVerifier]);
}
exports.setup_generic_prover_and_verifier = setup_generic_prover_and_verifier;
async function load_crs(circSize) {
    // We may need more elements in the SRS than the circuit size. In particular, we may need circSize +1
    // We add an offset here to account for that
    const offset = 1;
    const crs = new crs_1.Crs(circSize + offset);
    await crs.download();
    return crs;
}
async function create_proof(prover, acir, abi) {
    // compute partial witness here
    let witness_arr = await compute_partial_witnesses(acir, abi);
    // computes the proof
    const proof = await prover.createProof(witness_arr);
    return proof;
}
exports.create_proof = create_proof;
async function create_proof_with_witness(prover, witness_arr) {
    // computes the proof
    const proof = await prover.createProof(witness_arr);
    return proof;
}
exports.create_proof_with_witness = create_proof_with_witness;
async function verify_proof(verifier, proof) {
    const verified = await verifier.verifyProof(proof);
    return verified;
}
exports.verify_proof = verify_proof;
async function compute_partial_witnesses(circuit, abi) {
    // Use the ACIR representation to compute the partial witnesses
    // Assumption: .values() will always return the values in a deterministic order;
    // (from left to right) in the abi object
    let values = [];
    for (const [_, v] of Object.entries(abi)) {
        let entry_values = AnyToHexStrs(v);
        values = values.concat(entry_values);
    }
    return (0, aztec_backend_1.compute_witnesses)(circuit, values);
}
function AnyToHexStrs(any_object) {
    let values = [];
    if (Array.isArray(any_object)) {
        for (let variable of any_object) {
            values = values.concat(AnyToHexStrs(variable));
        }
    }
    else if (typeof any_object === 'string' || any_object instanceof String) {
        // If the type is a string, we expect it to be a hex string
        let string_object = any_object;
        if (isValidHex(string_object)) {
            values.push(string_object);
        }
        else {
            // TODO: throw should not be in a library, but currently we aren't doing 
            // TODO: much in terms of error handling
            throw new Error("strings can only be hexadecimal and must start with 0x");
        }
    }
    else if (Number.isInteger(any_object)) {
        let number_object = any_object;
        let number_hex = number_object.toString(16);
        // The rust code only accepts even hex digits
        let is_even_hex_length = number_hex.length % 2 == 0;
        if (is_even_hex_length) {
            values.push("0x" + number_hex);
        }
        else {
            values.push("0x0" + number_hex);
        }
    }
    else {
        throw new Error("unknown object type in the abi");
    }
    return values;
}
function isValidHex(hex_str) {
    return !isNaN(Number(hex_str));
}
function getNumCores() {
    // TODO: The below comment was when we had this in a separate package
    //
    // Barretenberg.js uses navigator.hardwareConcurrency which is
    // only available in the desktop environment, not in js
    //
    // No need to find a polyfill for it, as our circuit is so small
    return 4;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY2xpZW50X3Byb29mcy9nZW5lcmljX3Byb29mL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSwrQ0FBK0M7QUFDL0MsNERBSWtDO0FBQ2xDLG1DQUFnQztBQUNoQyxtQ0FBc0M7QUFDdEMsK0NBQWtEO0FBQ2xELHFDQUEwRDtBQUMxRCxzQ0FBbUM7QUFDbkMsdUVBQWtGO0FBQ2xGLDJFQUFzRTtBQUV0RSx5RUFBMEM7QUFDMUMsMkVBQTRDO0FBRTVDLDJEQUEyRDtBQUMzRCxvQ0FBb0M7QUFDcEMsRUFBRTtBQUNGLGdFQUFnRTtBQUNoRSxvREFBb0Q7QUFDcEQsRUFBRTtBQUNGLDREQUE0RDtBQUM1RCxFQUFFO0FBQ0YsaUVBQWlFO0FBQ2pFLDZCQUE2QjtBQUN0QixLQUFLLFVBQVUsaUNBQWlDLENBQUMsSUFBUztJQUMvRCxNQUFNLGtCQUFrQixHQUFHLElBQUEscURBQXFDLEVBQUMsSUFBSSxDQUFDLENBQUM7SUFFdkUsTUFBTSxZQUFZLEdBQUcsTUFBTSx1QkFBZ0IsQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUVsRCxNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUEsd0NBQWMsRUFBQyxZQUFZLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztJQUV4RSxNQUFNLEdBQUcsR0FBRyxNQUFNLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUVyQyxNQUFNLFVBQVUsR0FBRyxXQUFXLEVBQUUsQ0FBQztJQUVqQyxNQUFNLElBQUksR0FBRyxNQUFNLHVCQUFnQixDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQzFDLE1BQU0sVUFBVSxHQUFHLE1BQU0saUJBQVUsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQzFELE1BQU0sU0FBUyxHQUFHLElBQUksMkJBQWUsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUVsRCxNQUFNLEdBQUcsR0FBRyxJQUFJ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