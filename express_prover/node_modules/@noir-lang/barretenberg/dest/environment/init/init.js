"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InitHelpers = void 0;
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const bigint_buffer_1 = require("../../bigint_buffer");
const pathTools = (0, tslib_1.__importStar)(require("path"));
const init_config_1 = require("./init_config");
const NOTE_LENGTH = 32;
const ADDRESS_LENGTH = 64;
const ALIAS_HASH_LENGTH = 28;
const NULLIFIER_LENGTH = 32;
const SIGNING_KEY_LENGTH = 32;
class InitHelpers {
    static getInitData(chainId) {
        return {
            roots: InitHelpers.getInitRoots(chainId),
            dataTreeSize: InitHelpers.getInitDataSize(chainId),
        };
    }
    static getInitRoots(chainId) {
        const { initDataRoot, initNullRoot, initRootsRoot } = (0, init_config_1.getInitData)(chainId).initRoots;
        return {
            dataRoot: Buffer.from(initDataRoot, 'hex'),
            nullRoot: Buffer.from(initNullRoot, 'hex'),
            rootsRoot: Buffer.from(initRootsRoot, 'hex'),
        };
    }
    static getInitDataSize(chainId) {
        return (0, init_config_1.getInitData)(chainId).initDataSize;
    }
    static getInitAccounts(chainId) {
        return (0, init_config_1.getInitData)(chainId).initAccounts;
    }
    static getAccountDataFile(chainId) {
        if (!(0, init_config_1.getInitData)(chainId).accountsData) {
            return undefined;
        }
        const relPathToFile = (0, init_config_1.getInitData)(chainId).accountsData;
        const fullPath = pathTools.resolve(__dirname, relPathToFile);
        return fullPath;
    }
    static getRootDataFile(chainId) {
        if (!(0, init_config_1.getInitData)(chainId).roots) {
            return undefined;
        }
        const relPathToFile = (0, init_config_1.getInitData)(chainId).roots;
        const fullPath = pathTools.resolve(__dirname, relPathToFile);
        return fullPath;
    }
    static async writeData(filePath, data) {
        const path = pathTools.resolve(__dirname, filePath);
        const fileHandle = await fs_1.promises.open(path, 'w');
        const { bytesWritten } = await fileHandle.write(data);
        await fileHandle.close();
        return bytesWritten;
    }
    static async readData(filePath) {
        const path = pathTools.resolve(__dirname, filePath);
        try {
            const fileHandle = await fs_1.promises.open(path, 'r');
            const data = await fileHandle.readFile();
            await fileHandle.close();
            return data;
        }
        catch (err) {
            console.log(`Failed to read file: ${path}. Error: ${err}`);
            return Buffer.alloc(0);
        }
    }
    static async writeAccountTreeData(accountData, filePath) {
        accountData.forEach(account => {
            if (account.notes.note1.length !== NOTE_LENGTH) {
                throw new Error(`Note1 has length ${account.notes.note1.length}, it should be ${NOTE_LENGTH}`);
            }
            if (account.notes.note2.length !== NOTE_LENGTH) {
                throw new Error(`Note2 has length ${account.notes.note2.length}, it should be ${NOTE_LENGTH}`);
            }
            if (account.alias.aliasHash.length !== ALIAS_HASH_LENGTH) {
                throw new Error(`Alias hash has length ${account.alias.aliasHash.length}, it should be ${ALIAS_HASH_LENGTH}`);
            }
            if (account.alias.address.length !== ADDRESS_LENGTH) {
                throw new Error(`Alias grumpkin address has length ${account.alias.address.length}, it should be ${ADDRESS_LENGTH}`);
            }
            if (account.nullifiers.nullifier1.length !== NULLIFIER_LENGTH) {
                throw new Error(`Nullifier1 has length ${account.nullifiers.nullifier1.length}, it should be ${NULLIFIER_LENGTH}`);
            }
            if (account.nullifiers.nullifier2.length !== NULLIFIER_LENGTH) {
                throw new Error(`Nullifier1 has length ${account.nullifiers.nullifier2.length}, it should be ${NULLIFIER_LENGTH}`);
            }
            if (account.signingKeys.signingKey1.length !== SIGNING_KEY_LENGTH) {
                throw new Error(`Signing Key 1 has length ${account.signingKeys.signingKey1.length}, it should be ${SIGNING_KEY_LENGTH}`);
            }
            if (account.signingKeys.signingKey2.length !== SIGNING_KEY_LENGTH) {
                throw new Error(`Signing Key 2 has length ${account.signingKeys.signingKey2.length}, it should be ${SIGNING_KEY_LENGTH}`);
            }
        });
        const dataToWrite = accountData.flatMap(account => {
            return [
                account.alias.aliasHash,
                account.alias.address,
                account.notes.note1,
                account.notes.note2,
                account.nullifiers.nullifier1,
                account.nullifiers.nullifier2,
                account.signingKeys.signingKey1,
                account.signingKeys.signingKey2,
            ];
        });
        return await this.writeData(filePath, Buffer.concat(dataToWrite));
    }
    static parseAccountTreeData(data) {
        const lengthOfAccountData = ALIAS_HASH_LENGTH + ADDRESS_LENGTH + 2 * NOTE_LENGTH + 2 * NULLIFIER_LENGTH + 2 * SIGNING_KEY_LENGTH;
        const numAccounts = data.length / lengthOfAccountData;
        if (numAccounts === 0) {
            return [];
        }
        const accounts = new Array(numAccounts);
        for (let i = 0; i < numAccounts; i++) {
            let start = i * lengthOfAccountData;
            const alias = {
                aliasHash: data.slice(start, start + ALIAS_HASH_LENGTH),
                address: data.slice(start + ALIAS_HASH_LENGTH, start + (ALIAS_HASH_LENGTH + ADDRESS_LENGTH)),
            };
            start += ALIAS_HASH_LENGTH + ADDRESS_LENGTH;
            const notes = {
                note1: data.slice(start, start + NOTE_LENGTH),
                note2: data.slice(start + NOTE_LENGTH, start + 2 * NOTE_LENGTH),
            };
            start += 2 * NOTE_LENGTH;
            const nullifiers = {
                nullifier1: data.slice(start, start + NULLIFIER_LENGTH),
                nullifier2: data.slice(start + NULLIFIER_LENGTH, start + 2 * NULLIFIER_LENGTH),
            };
            start += 2 * NULLIFIER_LENGTH;
            const signingKeys = {
                signingKey1: data.slice(start, start + SIGNING_KEY_LENGTH),
                signingKey2: data.slice(start + SIGNING_KEY_LENGTH, start + 2 * SIGNING_KEY_LENGTH),
            };
            const account = {
                notes,
                nullifiers,
                alias,
                signingKeys,
            };
            accounts[i] = account;
        }
        return accounts;
    }
    static async readAccountTreeData(filePath) {
        const data = await this.readData(filePath);
        return this.parseAccountTreeData(data);
    }
    static async populateDataAndRootsTrees(accounts, merkleTree, dataTreeIndex, rootsTreeIndex, rollupSize) {
        const entries = accounts.flatMap((account, index) => {
            return [
                {
                    treeId: dataTreeIndex,
                    index: BigInt(index * 2),
                    value: account.notes.note1,
                },
                {
                    treeId: dataTreeIndex,
                    index: BigInt(1 + index * 2),
                    value: account.notes.note2,
                },
            ];
        });
        console.log(`Batch inserting ${entries.length} notes into data tree...`);
        await merkleTree.batchPut(entries);
        if (rollupSize) {
            // we need to expand the data tree to have 'full' rollups worth of notes in
            const numFullRollups = Math.floor(entries.length / rollupSize);
            const additional = entries.length % rollupSize ? 1 : 0;
            const notesRequired = (numFullRollups + additional) * rollupSize;
            if (notesRequired > entries.length) {
                await merkleTree.put(dataTreeIndex, BigInt(notesRequired - 1), Buffer.alloc(32, 0));
            }
        }
        const dataRoot = merkleTree.getRoot(dataTreeIndex);
        await merkleTree.put(rootsTreeIndex, BigInt(0), dataRoot);
        const rootsRoot = merkleTree.getRoot(rootsTreeIndex);
        const dataSize = merkleTree.getSize(dataTreeIndex);
        return { dataRoot, rootsRoot, dataSize };
    }
    static async populateNullifierTree(accounts, merkleTree, nullTreeIndex) {
        const emptyBuffer = Buffer.alloc(32, 0);
        const entries = accounts
            .flatMap(account => [account.nullifiers.nullifier1, account.nullifiers.nullifier2])
            .filter(nullifier => !nullifier.equals(emptyBuffer))
            .map((nullifier) => {
            return {
                treeId: nullTreeIndex,
                index: (0, bigint_buffer_1.toBigIntBE)(nullifier),
                value: (0, bigint_buffer_1.toBufferBE)(BigInt(1), 32),
            };
        });
        console.log(`Batch inserting ${entries.length} notes into nullifier tree...`);
        await merkleTree.batchPut(entries);
        const root = merkleTree.getRoot(nullTreeIndex);
        return root;
    }
}
exports.InitHelpers = InitHelpers;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5pdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9lbnZpcm9ubWVudC9pbml0L2luaXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDJCQUFvQztBQUVwQyx1REFBNkQ7QUFDN0QsNkRBQWtDO0FBQ2xDLCtDQUE0QztBQUU1QyxNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUM7QUFDdkIsTUFBTSxjQUFjLEdBQUcsRUFBRSxDQUFDO0FBQzFCLE1BQU0saUJBQWlCLEdBQUcsRUFBRSxDQUFDO0FBQzdCLE1BQU0sZ0JBQWdCLEdBQUcsRUFBRSxDQUFDO0FBQzVCLE1BQU0sa0JBQWtCLEdBQUcsRUFBRSxDQUFDO0FBd0M5QixNQUFhLFdBQVc7SUFDZixNQUFNLENBQUMsV0FBVyxDQUFDLE9BQWU7UUFDdkMsT0FBTztZQUNMLEtBQUssRUFBRSxXQUFXLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQztZQUN4QyxZQUFZLEVBQUUsV0FBVyxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUM7U0FDbkQsQ0FBQztJQUNKLENBQUM7SUFFTSxNQUFNLENBQUMsWUFBWSxDQUFDLE9BQWU7UUFDeEMsTUFBTSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFFLEdBQUcsSUFBQSx5QkFBVyxFQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQztRQUNyRixPQUFPO1lBQ0wsUUFBUSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLEtBQUssQ0FBQztZQUMxQyxRQUFRLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsS0FBSyxDQUFDO1lBQzFDLFNBQVMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxLQUFLLENBQUM7U0FDN0MsQ0FBQztJQUNKLENBQUM7SUFFTSxNQUFNLENBQUMsZUFBZSxDQUFDLE9BQWU7UUFDM0MsT0FBTyxJQUFBLHlCQUFXLEVBQUMsT0FBTyxDQUFDLENBQUMs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