{"id":"wMQ2","dependencies":[{"name":"/mnt/user-data/kev/tmp/aztec-connect/barretenberg.js/tsconfig.json","includedInParent":true,"mtime":1663687003068},{"name":"/mnt/user-data/kev/tmp/aztec-connect/barretenberg.js/package.json","includedInParent":true,"mtime":1663951495938},{"name":"./single_pedersen","loc":{"line":4,"column":34},"parent":"/mnt/user-data/kev/tmp/aztec-connect/barretenberg.js/src/crypto/pedersen/pooled_pedersen.ts","resolved":"/mnt/user-data/kev/tmp/aztec-connect/barretenberg.js/src/crypto/pedersen/single_pedersen.ts"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.PooledPedersen=void 0;const e=require(\"./single_pedersen\");class o extends e.SinglePedersen{constructor(o,s){super(o),this.pool=[],this.pool=s.workers.map(s=>new e.SinglePedersen(o,s))}async init(){await Promise.all(this.pool.map(e=>e.init()))}async hashToTree(e){if(!(e=>e&&!(e&e-1))(e.length))throw new Error(\"PooledPedersen::hashValuesToTree can only handle powers of 2.\");const o=Math.min(e.length/2,this.pool.length),s=this.pool.slice(0,Math.max(o,1)),t=e.length/s.length,l=(await Promise.all(s.map((o,s)=>o.hashToTree(e.slice(s*t,(s+1)*t))))).map(e=>{const o=[];for(let s=t,l=0;s>=1;l+=s,s/=2)o.push(e.slice(l,l+s));return o}),n=l[0];for(let r=1;r<l.length;++r)for(let e=0;e<l[r].length;++e)n[e]=[...n[e],...l[r][e]];for(;n[n.length-1].length>1;){const e=n[n.length-1],o=[];for(let s=0;s<e.length;s+=2)o[s/2]=this.pool[0].compress(e[s],e[s+1]);n.push(o)}return n.flat()}}exports.PooledPedersen=o;"},"sourceMaps":null,"error":null,"hash":"06fe76cbefa95106a35a708d789cba96","cacheData":{"env":{}}}