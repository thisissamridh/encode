{"id":"OvF0","dependencies":[{"name":"/mnt/user-data/kev/tmp/aztec-connect/barretenberg.js/package.json","includedInParent":true,"mtime":1663951495938},{"name":"/mnt/user-data/kev/tmp/aztec-connect/barretenberg.js/node_modules/threads/package.json","includedInParent":true,"mtime":1663107578820},{"name":"debug","loc":{"line":10,"column":24},"parent":"/mnt/user-data/kev/tmp/aztec-connect/barretenberg.js/node_modules/threads/dist-esm/master/pool.js","resolved":"/mnt/user-data/kev/tmp/aztec-connect/barretenberg.js/node_modules/debug/src/browser.js"},{"name":"observable-fns","loc":{"line":11,"column":47},"parent":"/mnt/user-data/kev/tmp/aztec-connect/barretenberg.js/node_modules/threads/dist-esm/master/pool.js","resolved":"/mnt/user-data/kev/tmp/aztec-connect/barretenberg.js/node_modules/observable-fns/dist.esm/index.js"},{"name":"../ponyfills","loc":{"line":12,"column":27},"parent":"/mnt/user-data/kev/tmp/aztec-connect/barretenberg.js/node_modules/threads/dist-esm/master/pool.js","resolved":"/mnt/user-data/kev/tmp/aztec-connect/barretenberg.js/node_modules/threads/dist-esm/ponyfills.js"},{"name":"./implementation","loc":{"line":13,"column":32},"parent":"/mnt/user-data/kev/tmp/aztec-connect/barretenberg.js/node_modules/threads/dist-esm/master/pool.js","resolved":"/mnt/user-data/kev/tmp/aztec-connect/barretenberg.js/node_modules/threads/dist-esm/master/implementation.browser.js"},{"name":"./pool-types","loc":{"line":14,"column":30},"parent":"/mnt/user-data/kev/tmp/aztec-connect/barretenberg.js/node_modules/threads/dist-esm/master/pool.js","resolved":"/mnt/user-data/kev/tmp/aztec-connect/barretenberg.js/node_modules/threads/dist-esm/master/pool-types.js"},{"name":"./thread","loc":{"line":15,"column":23},"parent":"/mnt/user-data/kev/tmp/aztec-connect/barretenberg.js/node_modules/threads/dist-esm/master/pool.js","resolved":"/mnt/user-data/kev/tmp/aztec-connect/barretenberg.js/node_modules/threads/dist-esm/master/thread.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.Pool=void 0,Object.defineProperty(exports,\"PoolEventType\",{enumerable:!0,get:function(){return s.PoolEventType}}),Object.defineProperty(exports,\"Thread\",{enumerable:!0,get:function(){return r.Thread}});var e=o(require(\"debug\")),t=require(\"observable-fns\"),n=require(\"../ponyfills\"),i=require(\"./implementation\"),s=require(\"./pool-types\"),r=require(\"./thread\");function o(e){return e&&e.__esModule?e:{default:e}}var u=function(e,t,n,i){return new(n||(n=Promise))(function(s,r){function o(e){try{a(i.next(e))}catch(t){r(t)}}function u(e){try{a(i.throw(e))}catch(t){r(t)}}function a(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n(function(e){e(t)})).then(o,u)}a((i=i.apply(e,t||[])).next())})};let a=1;function l(e){const t=[];for(let n=0;n<e;n++)t.push(n);return t}function h(e){return new Promise(t=>setTimeout(t,e))}function d(e,t){return e.reduce((e,n)=>[...e,...t(n)],[])}function c(e){return e.replace(/\\W/g,\" \").trim().replace(/\\s+/g,\"-\")}function p(e,t){return l(t).map(()=>({init:e(),runningTasks:[]}))}class b{constructor(n,r){this.eventSubject=new t.Subject,this.initErrors=[],this.isClosing=!1,this.nextTaskID=1,this.taskQueue=[];const o=\"number\"==typeof r?{size:r}:r||{},{size:u=i.defaultPoolSize}=o;this.debug=(0,e.default)(`threads:pool:${c(o.name||String(a++))}`),this.options=o,this.workers=p(n,u),this.eventObservable=(0,t.multicast)(t.Observable.from(this.eventSubject)),Promise.all(this.workers.map(e=>e.init)).then(()=>this.eventSubject.next({type:s.PoolEventType.initialized,size:this.workers.length}),e=>{this.debug(\"Error while initializing pool worker:\",e),this.eventSubject.error(e),this.initErrors.push(e)})}findIdlingWorker(){const{concurrency:e=1}=this.options;return this.workers.find(t=>t.runningTasks.length<e)}runPoolTask(e,t){return u(this,void 0,void 0,function*(){const n=this.workers.indexOf(e)+1;this.debug(`Running task #${t.id} on worker #${n}...`),this.eventSubject.next({type:s.PoolEventType.taskStart,taskID:t.id,workerID:n});try{const r=yield t.run(yield e.init);this.debug(`Task #${t.id} completed successfully`),this.eventSubject.next({type:s.PoolEventType.taskCompleted,returnValue:r,taskID:t.id,workerID:n})}catch(i){this.debug(`Task #${t.id} failed`),this.eventSubject.next({type:s.PoolEventType.taskFailed,taskID:t.id,error:i,workerID:n})}})}run(e,t){return u(this,void 0,void 0,function*(){const n=(()=>u(this,void 0,void 0,function*(){yield h(0);try{yield this.runPoolTask(e,t)}finally{e.runningTasks=e.runningTasks.filter(e=>e!==n),this.isClosing||this.scheduleWork()}}))();e.runningTasks.push(n)})}scheduleWork(){this.debug(\"Attempt de-queueing a task in order to run it...\");const e=this.findIdlingWorker();if(!e)return;const t=this.taskQueue.shift();if(!t)return this.debug(\"Task queue is empty\"),void this.eventSubject.next({type:s.PoolEventType.taskQueueDrained});this.run(e,t)}taskCompletion(e){return new Promise((t,n)=>{const i=this.events().subscribe(r=>{r.type===s.PoolEventType.taskCompleted&&r.taskID===e?(i.unsubscribe(),t(r.returnValue)):r.type===s.PoolEventType.taskFailed&&r.taskID===e?(i.unsubscribe(),n(r.error)):r.type===s.PoolEventType.terminated&&(i.unsubscribe(),n(Error(\"Pool has been terminated before task was run.\")))})})}settled(e=!1){return u(this,void 0,void 0,function*(){const t=()=>d(this.workers,e=>e.runningTasks),i=[],r=this.eventObservable.subscribe(e=>{e.type===s.PoolEventType.taskFailed&&i.push(e.error)});return this.initErrors.length>0?Promise.reject(this.initErrors[0]):e&&0===this.taskQueue.length?(yield(0,n.allSettled)(t()),i):(yield new Promise((e,t)=>{const n=this.eventObservable.subscribe({next(t){t.type===s.PoolEventType.taskQueueDrained&&(n.unsubscribe(),e(void 0))},error:t})}),yield(0,n.allSettled)(t()),r.unsubscribe(),i)})}completed(e=!1){return u(this,void 0,void 0,function*(){const t=this.settled(e),n=new Promise((e,n)=>{const i=this.eventObservable.subscribe({next(r){r.type===s.PoolEventType.taskQueueDrained?(i.unsubscribe(),e(t)):r.type===s.PoolEventType.taskFailed&&(i.unsubscribe(),n(r.error))},error:n})}),i=yield Promise.race([t,n]);if(i.length>0)throw i[0]})}events(){return this.eventObservable}queue(e){const{maxQueuedJobs:t=1/0}=this.options;if(this.isClosing)throw Error(\"Cannot schedule pool tasks after terminate() has been called.\");if(this.initErrors.length>0)throw this.initErrors[0];const n=this.nextTaskID++,i=this.taskCompletion(n);i.catch(e=>{this.debug(`Task #${n} errored:`,e)});const r={id:n,run:e,cancel:()=>{-1!==this.taskQueue.indexOf(r)&&(this.taskQueue=this.taskQueue.filter(e=>e!==r),this.eventSubject.next({type:s.PoolEventType.taskCanceled,taskID:r.id}))},then:i.then.bind(i)};if(this.taskQueue.length>=t)throw Error(\"Maximum number of pool tasks queued. Refusing to queue another one.\\nThis usually happens for one of two reasons: We are either at peak workload right now or some tasks just won't finish, thus blocking the pool.\");return this.debug(`Queueing task #${r.id}...`),this.taskQueue.push(r),this.eventSubject.next({type:s.PoolEventType.taskQueued,taskID:r.id}),this.scheduleWork(),r}terminate(e){return u(this,void 0,void 0,function*(){this.isClosing=!0,e||(yield this.completed(!0)),this.eventSubject.next({type:s.PoolEventType.terminated,remainingQueue:[...this.taskQueue]}),this.eventSubject.complete(),yield Promise.all(this.workers.map(e=>u(this,void 0,void 0,function*(){return r.Thread.terminate(yield e.init)})))})}}function k(e,t){return new b(e,t)}b.EventType=s.PoolEventType,k.EventType=s.PoolEventType;const v=k;exports.Pool=v;"},"sourceMaps":null,"error":null,"hash":"2c818b82dab5918f41c5431df6c8331b","cacheData":{"env":{}}}